<!--
/*
 * Copyright 2012 The Toolkitchen Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
-->
<element name="pi-feed-aggregator" attributes="feed count entries loading">
  <link rel="components" href="pi-gfeeds.html"/>
  <template>
    <pi-gfeeds id="gfeeds" feed="{{feedUrl}}" count="{{feedCount}}" results="{{feedResults}}" on-error="feedError"></pi-gfeeds>
  </template>
  <script>
    var GET_FAVICON_URL = 'http://s2.googleusercontent.com/s2/favicons?alt=feed&domain_url=';
    
    var timeSince = function(inDate) {
      var s = Math.floor(((new Date()) - inDate) / 1000);
      var t = Math.floor(s / 31536000);
      if (t > 1) {
        return t + 'y';
      }
      t = Math.floor(s / 2592000);
      if (t > 1) {
        return t + 'M';
      }
      t = Math.floor(s / 86400);
      if (t >= 1) {
        return t + 'd';
      }
      t = Math.floor(s / 3600);
      if (t >= 1) {
        return t + 'h';
      }
      t = Math.floor(s / 60);
      if (t > 1) {
        return t + 'm';
      }
      return Math.floor(s) + 's';
    };

    this.component({
      publish: {
        useCache: true,
        reload: function() {
          this.forceLoad = true;
          this.feedChanged();
        },
        resetCache: function() {
          this.feedCache = {};
        }
      },
      ready: function() {
        this.resetCache();
        this.contentNode = document.createElement('div');
      },
      feedChanged: function() {
        if (this.feed) {
          this._entries = [];
          this.feeds = Array.isArray(this.feed) ? this.feed.slice(0) : [{feed: this.feed}];
          this.feedCount = Math.ceil(this.count / this.feeds.length);
          this.fetch();
        } else {
          this.entries = null;
        }
      },
      fetch: function() {
        if (this.feeds && this.feeds.length) {
          // processing feeds one by one
          var f = this.feeds.shift().feed;
          if (!this.forceLoad && this.useCache && this.feedCache[f]) {
            //this.feedResults = this.feedCache[f];
            this.gotFeedResults(this.feedCache[f]);
          } else {
            // retrive feed data using pi-gfeeds (google Feed API)
            this.loading = true;
            this.feedUrl = f;
          }
        } else {
          // done processing all feeds
          this.fetchCompleted();
        }
      },
      fetchCompleted: function() {
        this.entries = this._entries.sort(this.dateSortDesc.bind(this));
        this.forceLoad = false;
        this.feedUrl = null;
        this.loading = false;
        this.send('response', {entries: this.entries});
      },
      gotFeedResults: function(inResults) {
        this.feedCache[inResults.feedUrl] = inResults;
        var entries = this.processFeedResults(inResults);
        this._entries.push.apply(this._entries, entries);
        this.fetch();
      },
      feedResultsChanged: function() {
        if (this.feedResults) {
          this.gotFeedResults(this.feedResults);
        }
      },
      feedError: function() {
        this.fetch();
      },
      dateSortDesc: function(inEntry1, inEntry2) {
        var d1 = inEntry1._date || new Date(inEntry1.publishedDate);
        var d2 = inEntry2._date || new Date(inEntry2.publishedDate);
        if (d1 > d2) {
          return -1;
        } else if (d1 < d2) {
          return 1;
        }
        return 0;
      },
      processFeedResults: function(inResults) {
        var n = this.contentNode;
        var entries = inResults.entries;
        entries.forEach(function(entry) {
          // feed source
          entry.source = inResults.title;
          entry.sourceLink = inResults.link;
          entry.feedUrl = inResults.feedUrl;
          // scrape image url
          if (!entry.imgSrc && entry.content) {
            var m$ = entry.content.match(/<img[^>]+src="([^">]+)"/);
            entry.imgSrc = m$ && m$[1];
          }
          entry.imageShowing = !!entry.imgSrc;
          // unescape html content
          if (!entry.desc && entry.contentSnippet) {
            n.innerHTML = entry.contentSnippet;
            n.innerHTML = n.textContent;
            entry.desc = n.textContent.trim();
            if (!entry.desc) {
              entry.desc = entry.title;
            }
          }
          // favicon
          if (entry.sourceLink) {
            entry.sourceIcon = GET_FAVICON_URL + entry.sourceLink;
          }
          // time since
          if (entry.publishedDate) {
            var d = entry._date || new Date(entry.publishedDate);
            entry._date = d;
            entry.since = timeSince(d);
          }
        });
        return entries;
      }
    });
  </script>
</element>
