<!--
/*
 * Copyright 2012 The Toolkitchen Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */
-->
<element name="pi-feed-viewer" attributes="panel layout">
  <link rel="stylesheet" href="css/pi-feed-viewer.css" />
  <link rel="components" href="../../../toolkit/components/g-panels.html"/>
  <link rel="components" href="pi-gfeeds.html"/>
  <link rel="components" href="pi-feed-aggregator.html"/>
  <link rel="components" href="pi-feed-tracker.html"/>
  <link rel="components" href="pi-items-view.html"/>
  <link rel="components" href="pi-story.html"/>
  <template>
    <g-panels id="panels" autoselect selected="{{panel}}" transition="keyframe" on-select="panelSelected" on-canselect="panelCanSelect">
      <pi-items-view id="topics" layout="{{layout}}" items="{{topics}}" view="topics" selected="{{selectedTopic}}"></pi-items-view>
      <pi-items-view id="stories" layout="{{layout}}" items="{{stories}}" selected="{{selectedStory}}" cascading></pi-items-view>
      <pi-story id="story" story="{{selectedStory}}" touch-action="pan-y" on-flick="storyFlickHandler" on-keydown="storyKeydownHandler"></pi-story>
    </g-panels>
    <div id="loading" loading="{{loading}}">Loading...</div>
    <pi-feed-aggregator id="feeds" feed="{{selectedTopic.feed}}" count="{{feedCount}}" entries="{{stories}}" loading="{{loading}}"></pi-feed-aggregator>
    <pi-feed-tracker id="tracker"></pi-feed-tracker>
  </template>
  <script>
    var RIGHT_ARROW_KEY = 39;
    var LEFT_ARROW_KEY = 37;
    
    // TODO(sorvell): if necessary, shouldn't go here
    var isEmpty = function(inObj) {
      if (inObj) {
        for (var i in inObj) {
          return false;
        }
      }
      return true;
    }
    
    this.component({
      publish: {
        topics: null,
        loading: true,
        selectedTopic: null,
        track: true,
        get canPrevious() {
          return this.$.panels.index;
        },
        previous: function() {
          this.$.panels.previous();
        },
        refresh: function() {
          if (this.panel == 'topics') {
            this.topicsChanged();
            this.$.feeds.resetCache();
          } else if (this.panel == 'stories') {
            this.$.feeds.reload();
          }
        }
      },
      feedCount: 200,
      ready: function() {
        var mq = window.matchMedia('(max-width: 800px)');
        mq.addListener(this.layoutChange.bind(this));
        this.layoutChange(mq);
        this.asyncMethod('loaded');
      },
      loaded: function() {
        this.loading = false;
      },
      layoutChange: function(inQuery) {
        this.$.panels.className = inQuery.matches ? 'g-panels-fly-up-right' : 
          'g-panels-scale-slide';
      },
      topicsChanged: function() {
        this.fetchImageForTopics();
        this.updateReadCount();
      },
      storiesChanged: function() {
        if (this.stories) {
          if (this.track) {
            this.$.tracker.loadStories(this.stories);
            this.updateReadCount(this.selectedTopic);
          }
          this.panel = 'stories';
          this.$.stories.loaded = false;
          this.asyncMethod('storiesLoaded');
        }
      },
      storiesLoaded: function() {
        this.$.stories.loaded = true;
      },
      selectedStoryChanged: function() {
        if (!isEmpty(this.selectedStory)) {
          if (this.track) {
            this.$.tracker.markRead(this.selectedStory);
            this.updateReadCount(this.selectedTopic);
          }
          this.panel = 'story';
        }
      },
      nextPrevStory: function(inNext, inPrev) {
        if (inPrev || inNext) {
          var i = this.stories.indexOf(this.selectedStory);
          var s = this.stories[i + (inPrev ? -1 : 1)];
          if (s) {
            this.selectedStory = s;
            return true;
          }
        }
      },
      fetchImageForTopics: function() {
        this.topics.forEach(function(t) {
          t.imgSrc = '';
          var fa = document.createElement('pi-feed-aggregator');
          fa.count = 4;
          fa.addEventListener('response', function(e) {
            var ns = e.detail && e.detail.entries || [];
            for (var i = 0, n; n = ns[i]; i++) {
              if (n.imgSrc) {
                t.imgSrc = n.imgSrc;
                return;
              }
            }
          });
          fa.feed = t.feed;
        });
      },
      updateReadCount: function(inTopic) {
        if (this.track) {
          var topics = inTopic ? [inTopic] : this.topics;
          topics.forEach(function(t) {
            t.unread = this.feedCount - this.$.tracker.getReadCountForTopic(t);
          }.bind(this));
        }
      },
      // TODO(sorvell): handle selected event since this fires after the selection
      // is complete and this is when we want to make the following changes.
      // note, we want selectedTopic/Story to become unset
      // when the panel that shows them is not selected, this allows
      // us to rely on selectedTopic/StoryChanged to show the relevant
      // panel.
      // it's important to set selectedTopic to {} so that
      // selectedTopic.feed actually changes and updates feeds.feed.
      panelSelected: function(e, inDetail, inSender) {
        if (e.target == this.$.panels) {
          if (inSender.selected == 'topics') {
            this.selectedTopic = {};
          } else if (inSender.selected == 'stories') {
            this.selectedStory = {};
          }
          //
          if (inSender.selected == 'story') {
            this.$.story.focus();
          } else {
            inSender.focus();
          }
        }
      },
      panelCanSelect: function(e, inDetail) {
        if ((inDetail.selected == 'stories' && (!this.stories && !this.$.feeds.loading)) || 
           (inDetail.selected == 'story' && isEmpty(this.selectedStory))) {
          inDetail.preventSelect();
        }
      },
      storyKeydownHandler: function(e) {
        var n = e.keyCode == RIGHT_ARROW_KEY, p = e.keyCode == LEFT_ARROW_KEY;
        if (this.nextPrevStory(n, p)) {
          e.cancelBubble = true;
        }
      },
      storyFlickHandler: function(e) {
        if (e.majorAxis == 'x' && e.pointerType === 'touch') {
          var n = e.xVelocity < 0, p = e.xVelocity > 0;
          if (this.nextPrevStory(n, p)) {
            e.cancelBubble = true;
          }
        }
      }
    });
  </script>
</element>
