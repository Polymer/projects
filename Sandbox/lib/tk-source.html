<!--
Copyright 2013 The Toolkitchen Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->
<element name="tk-source" attributes="element fontSize">
  <template>
    <ajaxorg-ace id="editor" mode="html" theme="chrome" tabSize="2"
        fontSize="{{fontSize}}" on-editor-change="editorChange"></ajaxorg-ace>
  </template>
  <script>
    Toolkit.register(this, {
      update: function(positionCursor) {
        // force components to update before dumping source
        Platform.flush();
        // given async effects a chance to apply to dom.
        this.asyncMethod('updateImmediate', [positionCursor]);
      },
      updateImmediate: function(positionCursor) {
        this.value = dumpTag(this.element.firstElementChild, '');
        this.$.editor.value = this.value;
        Platform.flush();
        if (positionCursor) {
          this.positionCursor();
        }
      },
      editorChange: function(event, detail) {
        this.send('source-changed', detail);
      },
      positionCursor: function() {
        this.$.editor.focus();
        this.$.editor.foldTag('style');
        var pos = this.$.editor.find('</style>', {start: 0});
        if (pos) {
          this.$.editor.gotoLine(pos.end.row + 2);
        }
      },
      shown: function() {
        this.positionCursor();
      }
    });
    
    var TAB = '  ';
    function dumpTag(e, indent) {
      if (e.dumpTag) {
        return e.dumpTag(dumpTag, indent, TAB);
      }
      if (e.nodeType == Node.TEXT_NODE) {
        return dumpTextNode(e);
      }
      var html = '';
      html += indent + '<' + e.localName;
      var attributes = dumpAttributes(e);
      Object.keys(attributes).forEach(function(k) {
        var v = attributes[k];
        //if (k !== 'class' || v != '') {
          html += ' ' + k + (v !== '' ? '="' + v + '"': '');
        //}
      })
      html += '>';
      var end = '</' + e.localName + '>\n';
      if (e.meta && e.meta.hideSubtree) {
        html += end;
      } else {
        if (e.firstElementChild) {
          Array.prototype.forEach.call(e.children, function(c, i) {
            if (i == 0) {
              html += '\n';
            }
            html += dumpTag(c, indent + TAB);
          });
          html += indent + end;
        } else {
          html += e.firstChild ? dumpTextNode(e.firstChild) + end : end;
        }
      }
      return html;
    }
    
    function dumpAttributes(node) {
      var p$ = Reflection.properties(node);
      var attributes = {};
      p$.forEach(function(p) {
        var v = p.value, n = p.name, binding = Toolkit.getBinding(node, n);
        if (n == 'textContent') {
          return;
        }
        if (binding) {
          v = '{{ ' + binding + ' }}';
        } else if (!((v || v === 0) && (typeof v === 'string' || typeof v === 'number' ||
            typeof v === 'boolean'))) {
          v = null;
        }
        if (v != null) {
          attributes[n] = v;
        }
      });
      for (var i=0, a; (a = node.attributes[i]); i++) {
        if (attributes[a.name] === undefined) {
          attributes[a.name] = a.value;
        }
      }
      return attributes;
    }
    
    function dumpTextNode(e) {
      var binding = Toolkit.getBinding(e, 'textContent');
      return binding ? '{{ ' + binding + ' }}' : e.textContent;
    }
  </script>
</element>
